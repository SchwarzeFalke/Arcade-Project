Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    COMMENT
    DECREMENT
    DEFAULT_CASE
    DIVIDEEQUAL
    DOT
    ERROR_SWITCH
    INCREMENT
    IN_STREAM
    LBRACKET
    LCURLY
    MINUS
    MINUSEQUAL
    ODD
    ODDEQUAL
    OUT_STREAM
    PLUSEQUAL
    POWER
    QUOTES
    RBRACKET
    RCURLY
    START_DECLARATION
    STRUCT_DECLARATION
    SWITCH_STATEMENT
    TIMESEQUAL

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> varDecl varAssign statement
Rule 3     varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN INTEGER SEMICOLON
Rule 4     varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN FLOAT SEMICOLON
Rule 5     varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN STRING SEMICOLON
Rule 6     varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_TRUE SEMICOLON
Rule 7     varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_FALSE SEMICOLON
Rule 8     varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON
Rule 9     varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON
Rule 10    varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON
Rule 11    varDecl -> empty
Rule 12    statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    statement -> IF_STATEMENT condition IF_NOT_STATEMENT statement
Rule 14    statement -> FOR_STATEMENT LPAREN statement RPAREN COLON statement
Rule 15    statement -> WHILE_STATEMENT LPAREN condition RPAREN COLON statement
Rule 16    statement -> empty
Rule 17    condition -> expression relation expression
Rule 18    relation -> IDENTICAL
Rule 19    relation -> DIFFERENT
Rule 20    relation -> GREATER
Rule 21    relation -> LESS
Rule 22    relation -> GREATEREQUAL
Rule 23    relation -> LESSEQUAL
Rule 24    expression -> IDENTIFIER
Rule 25    expression -> PLUS IDENTIFIER
Rule 26    expression -> expression PLUS IDENTIFIER
Rule 27    term -> factor
Rule 28    term -> term multiplyingOperator factor
Rule 29    multiplyingOperator -> TIMES
Rule 30    multiplyingOperator -> DIVIDE
Rule 31    factor -> IDENTIFIER
Rule 32    factor -> INTEGER
Rule 33    factor -> FLOAT
Rule 34    factor -> LPAREN expression RPAREN
Rule 35    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 3 4 5 6 7 8 9 10 12
BOOLEAN_FALSE        : 7
BOOLEAN_TRUE         : 6
COLON                : 14 15
COMMA                : 
COMMENT              : 
DECREMENT            : 
DEFAULT_CASE         : 
DIFFERENT            : 19
DIVIDE               : 30
DIVIDEEQUAL          : 
DOT                  : 
ERROR_SWITCH         : 
FLOAT                : 4 9 33
FOR_STATEMENT        : 14
GREATER              : 20
GREATEREQUAL         : 22
IDENTICAL            : 18
IDENTIFIER           : 3 4 5 6 7 8 9 10 12 24 25 26 31
IF_NOT_STATEMENT     : 13
IF_STATEMENT         : 13
INCREMENT            : 
INTEGER              : 3 8 32
IN_STREAM            : 
LBRACKET             : 
LCURLY               : 
LESS                 : 21
LESSEQUAL            : 23
LPAREN               : 14 15 34
MINUS                : 
MINUSEQUAL           : 
ODD                  : 
ODDEQUAL             : 
OUT_STREAM           : 
PLUS                 : 25 26
PLUSEQUAL            : 
POWER                : 
QUOTES               : 
RBRACKET             : 
RCURLY               : 
RPAREN               : 14 15 34
SEMICOLON            : 3 4 5 6 7 8 9 10 12
START_DECLARATION    : 
STRING               : 5 10
STRUCT_DECLARATION   : 
SWITCH_STATEMENT     : 
TIMES                : 29
TIMESEQUAL           : 
VAR_DECLARATION      : 3 4 5 6 7
WHILE_STATEMENT      : 15
error                : 

Nonterminals, with rules where they appear

block                : 1
condition            : 13 15
empty                : 11 16
expression           : 12 17 17 26 34
factor               : 27 28
multiplyingOperator  : 28
program              : 0
relation             : 17
statement            : 2 13 14 14 15
term                 : 28
varAssign            : 2
varDecl              : 2

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . varDecl varAssign statement
    (3) varDecl -> . VAR_DECLARATION IDENTIFIER ASSIGN INTEGER SEMICOLON
    (4) varDecl -> . VAR_DECLARATION IDENTIFIER ASSIGN FLOAT SEMICOLON
    (5) varDecl -> . VAR_DECLARATION IDENTIFIER ASSIGN STRING SEMICOLON
    (6) varDecl -> . VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_TRUE SEMICOLON
    (7) varDecl -> . VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_FALSE SEMICOLON
    (11) varDecl -> . empty
    (35) empty -> .

    VAR_DECLARATION shift and go to state 4
    IDENTIFIER      reduce using rule 35 (empty -> .)

    program                        shift and go to state 1
    block                          shift and go to state 2
    varDecl                        shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> varDecl . varAssign statement
    (8) varAssign -> . IDENTIFIER ASSIGN INTEGER SEMICOLON
    (9) varAssign -> . IDENTIFIER ASSIGN FLOAT SEMICOLON
    (10) varAssign -> . IDENTIFIER ASSIGN STRING SEMICOLON

    IDENTIFIER      shift and go to state 7

    varAssign                      shift and go to state 6

state 4

    (3) varDecl -> VAR_DECLARATION . IDENTIFIER ASSIGN INTEGER SEMICOLON
    (4) varDecl -> VAR_DECLARATION . IDENTIFIER ASSIGN FLOAT SEMICOLON
    (5) varDecl -> VAR_DECLARATION . IDENTIFIER ASSIGN STRING SEMICOLON
    (6) varDecl -> VAR_DECLARATION . IDENTIFIER ASSIGN BOOLEAN_TRUE SEMICOLON
    (7) varDecl -> VAR_DECLARATION . IDENTIFIER ASSIGN BOOLEAN_FALSE SEMICOLON

    IDENTIFIER      shift and go to state 8


state 5

    (11) varDecl -> empty .

    IDENTIFIER      reduce using rule 11 (varDecl -> empty .)


state 6

    (2) block -> varDecl varAssign . statement
    (12) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (13) statement -> . IF_STATEMENT condition IF_NOT_STATEMENT statement
    (14) statement -> . FOR_STATEMENT LPAREN statement RPAREN COLON statement
    (15) statement -> . WHILE_STATEMENT LPAREN condition RPAREN COLON statement
    (16) statement -> . empty
    (35) empty -> .

    IDENTIFIER      shift and go to state 10
    IF_STATEMENT    shift and go to state 11
    FOR_STATEMENT   shift and go to state 12
    WHILE_STATEMENT shift and go to state 13
    $end            reduce using rule 35 (empty -> .)

    statement                      shift and go to state 9
    empty                          shift and go to state 14

state 7

    (8) varAssign -> IDENTIFIER . ASSIGN INTEGER SEMICOLON
    (9) varAssign -> IDENTIFIER . ASSIGN FLOAT SEMICOLON
    (10) varAssign -> IDENTIFIER . ASSIGN STRING SEMICOLON

    ASSIGN          shift and go to state 15


state 8

    (3) varDecl -> VAR_DECLARATION IDENTIFIER . ASSIGN INTEGER SEMICOLON
    (4) varDecl -> VAR_DECLARATION IDENTIFIER . ASSIGN FLOAT SEMICOLON
    (5) varDecl -> VAR_DECLARATION IDENTIFIER . ASSIGN STRING SEMICOLON
    (6) varDecl -> VAR_DECLARATION IDENTIFIER . ASSIGN BOOLEAN_TRUE SEMICOLON
    (7) varDecl -> VAR_DECLARATION IDENTIFIER . ASSIGN BOOLEAN_FALSE SEMICOLON

    ASSIGN          shift and go to state 16


state 9

    (2) block -> varDecl varAssign statement .

    $end            reduce using rule 2 (block -> varDecl varAssign statement .)


state 10

    (12) statement -> IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 17


state 11

    (13) statement -> IF_STATEMENT . condition IF_NOT_STATEMENT statement
    (17) condition -> . expression relation expression
    (24) expression -> . IDENTIFIER
    (25) expression -> . PLUS IDENTIFIER
    (26) expression -> . expression PLUS IDENTIFIER

    IDENTIFIER      shift and go to state 20
    PLUS            shift and go to state 21

    condition                      shift and go to state 18
    expression                     shift and go to state 19

state 12

    (14) statement -> FOR_STATEMENT . LPAREN statement RPAREN COLON statement

    LPAREN          shift and go to state 22


state 13

    (15) statement -> WHILE_STATEMENT . LPAREN condition RPAREN COLON statement

    LPAREN          shift and go to state 23


state 14

    (16) statement -> empty .

    $end            reduce using rule 16 (statement -> empty .)
    RPAREN          reduce using rule 16 (statement -> empty .)


state 15

    (8) varAssign -> IDENTIFIER ASSIGN . INTEGER SEMICOLON
    (9) varAssign -> IDENTIFIER ASSIGN . FLOAT SEMICOLON
    (10) varAssign -> IDENTIFIER ASSIGN . STRING SEMICOLON

    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    STRING          shift and go to state 26


state 16

    (3) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN . INTEGER SEMICOLON
    (4) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN . FLOAT SEMICOLON
    (5) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN . STRING SEMICOLON
    (6) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN . BOOLEAN_TRUE SEMICOLON
    (7) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN . BOOLEAN_FALSE SEMICOLON

    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    BOOLEAN_TRUE    shift and go to state 30
    BOOLEAN_FALSE   shift and go to state 31


state 17

    (12) statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (24) expression -> . IDENTIFIER
    (25) expression -> . PLUS IDENTIFIER
    (26) expression -> . expression PLUS IDENTIFIER

    IDENTIFIER      shift and go to state 20
    PLUS            shift and go to state 21

    expression                     shift and go to state 32

state 18

    (13) statement -> IF_STATEMENT condition . IF_NOT_STATEMENT statement

    IF_NOT_STATEMENT shift and go to state 33


state 19

    (17) condition -> expression . relation expression
    (26) expression -> expression . PLUS IDENTIFIER
    (18) relation -> . IDENTICAL
    (19) relation -> . DIFFERENT
    (20) relation -> . GREATER
    (21) relation -> . LESS
    (22) relation -> . GREATEREQUAL
    (23) relation -> . LESSEQUAL

    PLUS            shift and go to state 35
    IDENTICAL       shift and go to state 36
    DIFFERENT       shift and go to state 37
    GREATER         shift and go to state 38
    LESS            shift and go to state 39
    GREATEREQUAL    shift and go to state 40
    LESSEQUAL       shift and go to state 41

    relation                       shift and go to state 34

state 20

    (24) expression -> IDENTIFIER .

    PLUS            reduce using rule 24 (expression -> IDENTIFIER .)
    IDENTICAL       reduce using rule 24 (expression -> IDENTIFIER .)
    DIFFERENT       reduce using rule 24 (expression -> IDENTIFIER .)
    GREATER         reduce using rule 24 (expression -> IDENTIFIER .)
    LESS            reduce using rule 24 (expression -> IDENTIFIER .)
    GREATEREQUAL    reduce using rule 24 (expression -> IDENTIFIER .)
    LESSEQUAL       reduce using rule 24 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 24 (expression -> IDENTIFIER .)
    IF_NOT_STATEMENT reduce using rule 24 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 24 (expression -> IDENTIFIER .)


state 21

    (25) expression -> PLUS . IDENTIFIER

    IDENTIFIER      shift and go to state 42


state 22

    (14) statement -> FOR_STATEMENT LPAREN . statement RPAREN COLON statement
    (12) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (13) statement -> . IF_STATEMENT condition IF_NOT_STATEMENT statement
    (14) statement -> . FOR_STATEMENT LPAREN statement RPAREN COLON statement
    (15) statement -> . WHILE_STATEMENT LPAREN condition RPAREN COLON statement
    (16) statement -> . empty
    (35) empty -> .

    IDENTIFIER      shift and go to state 10
    IF_STATEMENT    shift and go to state 11
    FOR_STATEMENT   shift and go to state 12
    WHILE_STATEMENT shift and go to state 13
    RPAREN          reduce using rule 35 (empty -> .)

    statement                      shift and go to state 43
    empty                          shift and go to state 14

state 23

    (15) statement -> WHILE_STATEMENT LPAREN . condition RPAREN COLON statement
    (17) condition -> . expression relation expression
    (24) expression -> . IDENTIFIER
    (25) expression -> . PLUS IDENTIFIER
    (26) expression -> . expression PLUS IDENTIFIER

    IDENTIFIER      shift and go to state 20
    PLUS            shift and go to state 21

    condition                      shift and go to state 44
    expression                     shift and go to state 19

state 24

    (8) varAssign -> IDENTIFIER ASSIGN INTEGER . SEMICOLON

    SEMICOLON       shift and go to state 45


state 25

    (9) varAssign -> IDENTIFIER ASSIGN FLOAT . SEMICOLON

    SEMICOLON       shift and go to state 46


state 26

    (10) varAssign -> IDENTIFIER ASSIGN STRING . SEMICOLON

    SEMICOLON       shift and go to state 47


state 27

    (3) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN INTEGER . SEMICOLON

    SEMICOLON       shift and go to state 48


state 28

    (4) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN FLOAT . SEMICOLON

    SEMICOLON       shift and go to state 49


state 29

    (5) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN STRING . SEMICOLON

    SEMICOLON       shift and go to state 50


state 30

    (6) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_TRUE . SEMICOLON

    SEMICOLON       shift and go to state 51


state 31

    (7) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_FALSE . SEMICOLON

    SEMICOLON       shift and go to state 52


state 32

    (12) statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (26) expression -> expression . PLUS IDENTIFIER

    SEMICOLON       shift and go to state 53
    PLUS            shift and go to state 35


state 33

    (13) statement -> IF_STATEMENT condition IF_NOT_STATEMENT . statement
    (12) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (13) statement -> . IF_STATEMENT condition IF_NOT_STATEMENT statement
    (14) statement -> . FOR_STATEMENT LPAREN statement RPAREN COLON statement
    (15) statement -> . WHILE_STATEMENT LPAREN condition RPAREN COLON statement
    (16) statement -> . empty
    (35) empty -> .

    IDENTIFIER      shift and go to state 10
    IF_STATEMENT    shift and go to state 11
    FOR_STATEMENT   shift and go to state 12
    WHILE_STATEMENT shift and go to state 13
    $end            reduce using rule 35 (empty -> .)
    RPAREN          reduce using rule 35 (empty -> .)

    statement                      shift and go to state 54
    empty                          shift and go to state 14

state 34

    (17) condition -> expression relation . expression
    (24) expression -> . IDENTIFIER
    (25) expression -> . PLUS IDENTIFIER
    (26) expression -> . expression PLUS IDENTIFIER

    IDENTIFIER      shift and go to state 20
    PLUS            shift and go to state 21

    expression                     shift and go to state 55

state 35

    (26) expression -> expression PLUS . IDENTIFIER

    IDENTIFIER      shift and go to state 56


state 36

    (18) relation -> IDENTICAL .

    IDENTIFIER      reduce using rule 18 (relation -> IDENTICAL .)
    PLUS            reduce using rule 18 (relation -> IDENTICAL .)


state 37

    (19) relation -> DIFFERENT .

    IDENTIFIER      reduce using rule 19 (relation -> DIFFERENT .)
    PLUS            reduce using rule 19 (relation -> DIFFERENT .)


state 38

    (20) relation -> GREATER .

    IDENTIFIER      reduce using rule 20 (relation -> GREATER .)
    PLUS            reduce using rule 20 (relation -> GREATER .)


state 39

    (21) relation -> LESS .

    IDENTIFIER      reduce using rule 21 (relation -> LESS .)
    PLUS            reduce using rule 21 (relation -> LESS .)


state 40

    (22) relation -> GREATEREQUAL .

    IDENTIFIER      reduce using rule 22 (relation -> GREATEREQUAL .)
    PLUS            reduce using rule 22 (relation -> GREATEREQUAL .)


state 41

    (23) relation -> LESSEQUAL .

    IDENTIFIER      reduce using rule 23 (relation -> LESSEQUAL .)
    PLUS            reduce using rule 23 (relation -> LESSEQUAL .)


state 42

    (25) expression -> PLUS IDENTIFIER .

    PLUS            reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    IDENTICAL       reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    DIFFERENT       reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    GREATER         reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    LESS            reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    GREATEREQUAL    reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    LESSEQUAL       reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    SEMICOLON       reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    IF_NOT_STATEMENT reduce using rule 25 (expression -> PLUS IDENTIFIER .)
    RPAREN          reduce using rule 25 (expression -> PLUS IDENTIFIER .)


state 43

    (14) statement -> FOR_STATEMENT LPAREN statement . RPAREN COLON statement

    RPAREN          shift and go to state 57


state 44

    (15) statement -> WHILE_STATEMENT LPAREN condition . RPAREN COLON statement

    RPAREN          shift and go to state 58


state 45

    (8) varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .

    IDENTIFIER      reduce using rule 8 (varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .)
    IF_STATEMENT    reduce using rule 8 (varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .)
    FOR_STATEMENT   reduce using rule 8 (varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .)
    WHILE_STATEMENT reduce using rule 8 (varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .)
    $end            reduce using rule 8 (varAssign -> IDENTIFIER ASSIGN INTEGER SEMICOLON .)


state 46

    (9) varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .

    IDENTIFIER      reduce using rule 9 (varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .)
    IF_STATEMENT    reduce using rule 9 (varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .)
    FOR_STATEMENT   reduce using rule 9 (varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .)
    WHILE_STATEMENT reduce using rule 9 (varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .)
    $end            reduce using rule 9 (varAssign -> IDENTIFIER ASSIGN FLOAT SEMICOLON .)


state 47

    (10) varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .

    IDENTIFIER      reduce using rule 10 (varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .)
    IF_STATEMENT    reduce using rule 10 (varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .)
    FOR_STATEMENT   reduce using rule 10 (varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .)
    WHILE_STATEMENT reduce using rule 10 (varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .)
    $end            reduce using rule 10 (varAssign -> IDENTIFIER ASSIGN STRING SEMICOLON .)


state 48

    (3) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN INTEGER SEMICOLON .

    IDENTIFIER      reduce using rule 3 (varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN INTEGER SEMICOLON .)


state 49

    (4) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN FLOAT SEMICOLON .

    IDENTIFIER      reduce using rule 4 (varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN FLOAT SEMICOLON .)


state 50

    (5) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN STRING SEMICOLON .

    IDENTIFIER      reduce using rule 5 (varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN STRING SEMICOLON .)


state 51

    (6) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_TRUE SEMICOLON .

    IDENTIFIER      reduce using rule 6 (varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_TRUE SEMICOLON .)


state 52

    (7) varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_FALSE SEMICOLON .

    IDENTIFIER      reduce using rule 7 (varDecl -> VAR_DECLARATION IDENTIFIER ASSIGN BOOLEAN_FALSE SEMICOLON .)


state 53

    (12) statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 12 (statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 54

    (13) statement -> IF_STATEMENT condition IF_NOT_STATEMENT statement .

    $end            reduce using rule 13 (statement -> IF_STATEMENT condition IF_NOT_STATEMENT statement .)
    RPAREN          reduce using rule 13 (statement -> IF_STATEMENT condition IF_NOT_STATEMENT statement .)


state 55

    (17) condition -> expression relation expression .
    (26) expression -> expression . PLUS IDENTIFIER

    IF_NOT_STATEMENT reduce using rule 17 (condition -> expression relation expression .)
    RPAREN          reduce using rule 17 (condition -> expression relation expression .)
    PLUS            shift and go to state 35


state 56

    (26) expression -> expression PLUS IDENTIFIER .

    PLUS            reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    IDENTICAL       reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    DIFFERENT       reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    GREATER         reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    LESS            reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    GREATEREQUAL    reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    LESSEQUAL       reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    SEMICOLON       reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    IF_NOT_STATEMENT reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)
    RPAREN          reduce using rule 26 (expression -> expression PLUS IDENTIFIER .)


state 57

    (14) statement -> FOR_STATEMENT LPAREN statement RPAREN . COLON statement

    COLON           shift and go to state 59


state 58

    (15) statement -> WHILE_STATEMENT LPAREN condition RPAREN . COLON statement

    COLON           shift and go to state 60


state 59

    (14) statement -> FOR_STATEMENT LPAREN statement RPAREN COLON . statement
    (12) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (13) statement -> . IF_STATEMENT condition IF_NOT_STATEMENT statement
    (14) statement -> . FOR_STATEMENT LPAREN statement RPAREN COLON statement
    (15) statement -> . WHILE_STATEMENT LPAREN condition RPAREN COLON statement
    (16) statement -> . empty
    (35) empty -> .

    IDENTIFIER      shift and go to state 10
    IF_STATEMENT    shift and go to state 11
    FOR_STATEMENT   shift and go to state 12
    WHILE_STATEMENT shift and go to state 13
    $end            reduce using rule 35 (empty -> .)
    RPAREN          reduce using rule 35 (empty -> .)

    statement                      shift and go to state 61
    empty                          shift and go to state 14

state 60

    (15) statement -> WHILE_STATEMENT LPAREN condition RPAREN COLON . statement
    (12) statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (13) statement -> . IF_STATEMENT condition IF_NOT_STATEMENT statement
    (14) statement -> . FOR_STATEMENT LPAREN statement RPAREN COLON statement
    (15) statement -> . WHILE_STATEMENT LPAREN condition RPAREN COLON statement
    (16) statement -> . empty
    (35) empty -> .

    IDENTIFIER      shift and go to state 10
    IF_STATEMENT    shift and go to state 11
    FOR_STATEMENT   shift and go to state 12
    WHILE_STATEMENT shift and go to state 13
    $end            reduce using rule 35 (empty -> .)
    RPAREN          reduce using rule 35 (empty -> .)

    statement                      shift and go to state 62
    empty                          shift and go to state 14

state 61

    (14) statement -> FOR_STATEMENT LPAREN statement RPAREN COLON statement .

    $end            reduce using rule 14 (statement -> FOR_STATEMENT LPAREN statement RPAREN COLON statement .)
    RPAREN          reduce using rule 14 (statement -> FOR_STATEMENT LPAREN statement RPAREN COLON statement .)


state 62

    (15) statement -> WHILE_STATEMENT LPAREN condition RPAREN COLON statement .

    $end            reduce using rule 15 (statement -> WHILE_STATEMENT LPAREN condition RPAREN COLON statement .)
    RPAREN          reduce using rule 15 (statement -> WHILE_STATEMENT LPAREN condition RPAREN COLON statement .)

